# Combined Agent TDD Feedback Loop (CodeRabbit + TestSprite)

## TDD & Automated Code Review Workflow

- For every change:
  - Write or generate relevant tests first (TDD principle).
  - Implement the feature or refactor.

## CodeRabbit CLI Feedback Loop

- After each code or test modification:
  - Run CodeRabbit CLI with prompt-optimized output:
    ```
    coderabbit --prompt-only
    ```
  - Parse CodeRabbit’s review for:
    - Logic errors, code smells, style violations
    - Security vulnerabilities and bad practices
    - Missed or inadequate test coverage
    - Performance and architecture concerns

- For every CodeRabbit finding:
  - Attempt to auto-fix or suggest the minimal code/test changes to address the issue.
  - Re-run the full test suite (with TestSprite) and repeat the CodeRabbit review.
  - **Loop**: Continue this process until `coderabbit --prompt-only` returns no critical/blocking issues left.

## Merge Policy

- No commits or PRs should be merged until both TestSprite and CodeRabbit reviews pass with zero critical issues or failing tests.
- Document each iteration, with summaries of fixes, tests added, and remaining issues (if any).

---

**Agent Prompt:**

> “For every change, run a full CodeRabbit CLI review (`coderabbit --prompt-only`), auto-fix all critical issues (code, security, and test coverage), and repeat until the codebase is free of unresolved review findings. Integrate this with the TestSprite TDD feedback loop.”

---

**Expected Outcome:**  
You get complete, incognito AI-augmented code review and enforcement: TDD test generation/updating with TestSprite, and senior-engineer-level iterative code review/auto-fix with CodeRabbit, cycling both until your project is solid, secure, and fully tested.

---

## System and Software Design Principles

- SOLID
  - Single Responsibility: each module/class has one reason to change.
  - Open/Closed: open for extension, closed for modification.
  - Liskov Substitution: derived types must be substitutable for base types.
  - Interface Segregation: prefer small, client-specific interfaces.
  - Dependency Inversion: depend on abstractions; inject dependencies.
- DRY, KISS, YAGNI: avoid duplication, keep designs simple, build only what’s needed.
- Clean Architecture / Hexagonal: separate domain, application, and infrastructure; keep core logic independent of frameworks.
- Composition over inheritance: favor strategies, adapters, decorators over deep inheritance.
- Error handling & observability: clear error boundaries, structured logging, metrics, and tracing.
- Security by default: least privilege, input validation, safe defaults, secrets management.
- Performance & scalability: consider Big-O, memory, batching, caching with safe invalidation.
- Configuration & 12-factor: externalized config via env vars; stateless processes when possible.
- Testing pyramid: fast unit tests, meaningful integration tests, targeted e2e; tests should be deterministic and isolated.
- Backward compatibility & versioning: avoid breaking changes; provide migrations or adapters.
- Documentation & readability: expressive naming, clear interfaces, ADRs for significant decisions.

These principles should guide:
- Test design and refactoring choices.
- CodeRabbit review interpretations and fixes.
- Architectural decisions (e.g., introducing interfaces, extracting boundaries, dependency injection).
